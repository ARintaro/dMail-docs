<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Concurrent hash maps."><title>chashmap - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fbd14db5c88ed452.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="chashmap" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (ec2f40c6b 2023-03-30)" data-search-js="search-bc5a112813b5d712.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-d4a1a279bad1a0c0.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-9ade54abd4bd73c8.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../chashmap/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../chashmap/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate chashmap</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 2.2.2</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#structs">Structs</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a class="mod" href="#">chashmap</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/chashmap/lib.rs.html#1-1019">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Concurrent hash maps.</p>
<p>This crate implements concurrent hash maps, based on bucket-level multi-reader locks. It has
excellent performance characteristics¹ and supports resizing, in-place mutation and more.</p>
<p>The API derives directly from <code>std::collections::HashMap</code>, giving it a familiar feel.</p>
<p>¹Note that it heavily depends on the behavior of your program, but in most cases, it’s really
good. In some (rare) cases you might want atomic hash maps instead.</p>
<h2 id="how-it-works"><a href="#how-it-works">How it works</a></h2>
<p><code>chashmap</code> is not lockless, but it distributes locks across the map such that lock contentions
(which is what could make accesses expensive) are very rare.</p>
<p>Hash maps consists of so called “buckets”, which each defines a potential entry in the table.
The bucket of some key-value pair is determined by the hash of the key. By holding a read-write
lock for each bucket, we ensure that you will generally be able to insert, read, modify, etc.
with only one or two locking subroutines.</p>
<p>There is a special-case: reallocation. When the table is filled up such that very few buckets
are free (note that this is “very few” and not “no”, since the load factor shouldn’t get too
high as it hurts performance), a global lock is obtained while rehashing the table. This is
pretty inefficient, but it rarely happens, and due to the adaptive nature of the capacity, it
will only happen a few times when the map has just been initialized.</p>
<h3 id="collision-resolution"><a href="#collision-resolution">Collision resolution</a></h3>
<p>When two hashes collide, they cannot share the same bucket, so there must be an algorithm which
can resolve collisions. In our case, we use linear probing, which means that we take the bucket
following it, and repeat until we find a free bucket.</p>
<p>This method is far from ideal, but superior methods like Robin-Hood hashing works poorly (if at
all) in a concurrent structure.</p>
<h2 id="the-api"><a href="#the-api">The API</a></h2>
<p>The API should feel very familiar, if you are used to the libstd hash map implementation. They
share many of the methods, and I’ve carefully made sure that all the items, which have similarly
named items in libstd, matches in semantics and behavior.</p>
</div></details><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.CHashMap.html" title="struct chashmap::CHashMap">CHashMap</a></div><div class="desc docblock-short">A concurrent hash map.</div></li><li><div class="item-name"><a class="struct" href="struct.IntoIter.html" title="struct chashmap::IntoIter">IntoIter</a></div><div class="desc docblock-short">An iterator over the entries of some table.</div></li><li><div class="item-name"><a class="struct" href="struct.ReadGuard.html" title="struct chashmap::ReadGuard">ReadGuard</a></div><div class="desc docblock-short">A RAII guard for reading an entry of a hash map.</div></li><li><div class="item-name"><a class="struct" href="struct.WriteGuard.html" title="struct chashmap::WriteGuard">WriteGuard</a></div><div class="desc docblock-short">A mutable RAII guard for reading an entry of a hash map.</div></li></ul></section></div></main></body></html>