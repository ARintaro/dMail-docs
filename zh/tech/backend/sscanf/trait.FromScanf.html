<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A trait that allows you to use a custom regex for parsing a type."><title>FromScanf in sscanf - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-fbd14db5c88ed452.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="sscanf" data-themes="" data-resource-suffix="" data-rustdoc-version="1.70.0-nightly (ec2f40c6b 2023-03-30)" data-search-js="search-bc5a112813b5d712.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" data-theme-light-css="light-db279b6232be9c13.css" data-theme-dark-css="dark-cf923f49f397b216.css" data-theme-ayu-css="ayu-be46fdc453a55015.css" ></div><script src="../static.files/storage-d4a1a279bad1a0c0.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-9ade54abd4bd73c8.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-db279b6232be9c13.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-cf923f49f397b216.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc trait"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../sscanf/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../sscanf/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">FromScanf</a></h2><div class="sidebar-elems"><section><h3><a href="#required-associated-types">Required Associated Types</a></h3><ul class="block"><li><a href="#associatedtype.Err">Err</a></li></ul><h3><a href="#required-associated-consts">Required Associated Constants</a></h3><ul class="block"><li><a href="#associatedconstant.NUM_CAPTURES">NUM_CAPTURES</a></li></ul><h3><a href="#required-methods">Required Methods</a></h3><ul class="block"><li><a href="#tymethod.from_matches">from_matches</a></li></ul><h3><a href="#implementors">Implementors</a></h3></section><h2><a href="index.html">In sscanf</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Trait <a href="index.html">sscanf</a>::<wbr><a class="trait" href="#">FromScanf</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/sscanf/from_scanf.rs.html#200-215">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub trait FromScanf&lt;'t&gt;<span class="where fmt-newline">where
    Self: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</span>{
    type <a href="#associatedtype.Err" class="associatedtype">Err</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/error/trait.Error.html" title="trait core::error::Error">Error</a> + 'static;

    const <a href="#associatedconstant.NUM_CAPTURES" class="constant">NUM_CAPTURES</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a>;

    // Required method
    fn <a href="#tymethod.from_matches" class="fn">from_matches</a>(
        src: &amp;mut SubCaptureMatches&lt;'_, 't&gt;
    ) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="trait.FromScanf.html#associatedtype.Err" title="type sscanf::FromScanf::Err">Err</a>&gt;;
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A trait that allows you to use a custom regex for parsing a type.</p>
<p>There are three options to implement this trait:</p>
<ul>
<li><code>#[derive(FromScanf)]</code> (recommended)</li>
<li>implement <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>std::str::FromStr</code></a> and relying on the <a href="#impl-FromScanf%3C%27t%3E">blanket implementation</a></li>
<li>manual implementation (highly discouraged)</li>
</ul>
<p>The second and third options also require you to implement <a href="trait.RegexRepresentation.html" title="trait sscanf::RegexRepresentation"><code>RegexRepresentation</code></a>,
unless you <strong>always</strong> use a custom regex <code>{:/.../}</code>, but that tends to make the code less readable.</p>
<h3 id="option-1-deriving"><a href="#option-1-deriving">Option 1: Deriving</a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(sscanf::FromScanf)]
#[sscanf(format = <span class="string">&quot;#{r:r16}{g:r16}{b:r16}&quot;</span>)] </span><span class="comment">// matches &#39;#&#39; followed by 3 hexadecimal u8s
</span><span class="kw">struct </span>Color {                               <span class="comment">// note the use of :r16 over :x to avoid prefixes
    </span>r: u8,
    g: u8,
    b: u8,
}

<span class="kw">let </span>input = <span class="string">&quot;color: #ff12cc&quot;</span>;
<span class="kw">let </span>parsed = <span class="macro">sscanf::sscanf!</span>(input, <span class="string">&quot;color: {Color}&quot;</span>).unwrap();
<span class="macro">assert_eq!</span>(parsed.r, <span class="number">0xff</span>);
<span class="macro">assert_eq!</span>(parsed.g, <span class="number">0x12</span>);
<span class="macro">assert_eq!</span>(parsed.b, <span class="number">0xcc</span>);</code></pre></div>
<p>A detailed description of the syntax and options can be found <a href="derive.FromScanf.html">here</a></p>
<h3 id="option-2-implementing-fromstr"><a href="#option-2-implementing-fromstr">Option 2: Implementing <code>FromStr</code></a></h3>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Color {
    r: u8,
    g: u8,
    b: u8,
}

<span class="kw">impl </span>sscanf::RegexRepresentation <span class="kw">for </span>Color {
    <span class="comment">// matches &#39;#&#39; followed by 6 hexadecimal digits
    </span><span class="kw">const </span>REGEX: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str = <span class="string">r&quot;#[0-9a-fA-F]{6}&quot;</span>;
}

<span class="attr">#[derive(Debug, thiserror::Error)]
</span><span class="kw">enum </span>ColorParseError {
    <span class="attr">#[error(<span class="string">&quot;Invalid digit&quot;</span>)]
    </span>InvalidHexDigit(<span class="attr">#[from] </span>std::num::ParseIntError),
    <span class="attr">#[error(<span class="string">&quot;Expected 6 hex digits, found {0}&quot;</span>)]
    </span>InvalidLength(usize),
    <span class="attr">#[error(<span class="string">&quot;Color has to be prefixed with &#39;#&#39;&quot;</span>)]
    </span>InvalidPrefix,
}
<span class="kw">impl </span>std::str::FromStr <span class="kw">for </span>Color {
    <span class="kw">type </span><span class="prelude-val">Err </span>= ColorParseError;
    <span class="kw">fn </span>from_str(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="kw">let </span>s = s.strip_prefix(<span class="string">&#39;#&#39;</span>)
                 .ok_or(ColorParseError::InvalidPrefix)<span class="question-mark">?</span>;
        <span class="kw">if </span>s.len() != <span class="number">6 </span>{
            <span class="kw">return </span><span class="prelude-val">Err</span>(ColorParseError::InvalidLength(s.len()));
        }
        <span class="kw">let </span>r = u8::from_str_radix(<span class="kw-2">&amp;</span>s[<span class="number">0</span>..<span class="number">2</span>], <span class="number">16</span>)<span class="question-mark">?</span>;
        <span class="kw">let </span>g = u8::from_str_radix(<span class="kw-2">&amp;</span>s[<span class="number">2</span>..<span class="number">4</span>], <span class="number">16</span>)<span class="question-mark">?</span>;
        <span class="kw">let </span>b = u8::from_str_radix(<span class="kw-2">&amp;</span>s[<span class="number">4</span>..<span class="number">6</span>], <span class="number">16</span>)<span class="question-mark">?</span>;
        <span class="prelude-val">Ok</span>(Color { r, g, b })
    }
}

<span class="kw">let </span>input = <span class="string">&quot;color: #ff12cc&quot;</span>;
<span class="kw">let </span>parsed = <span class="macro">sscanf::sscanf!</span>(input, <span class="string">&quot;color: {Color}&quot;</span>).unwrap();
<span class="macro">assert_eq!</span>(parsed.r, <span class="number">0xff</span>); <span class="macro">assert_eq!</span>(parsed.g, <span class="number">0x12</span>); <span class="macro">assert_eq!</span>(parsed.b, <span class="number">0xcc</span>);</code></pre></div>
<p>This option gives a lot more control over the parsing process, but requires more code and
manual error handling.</p>
<h3 id="option-3-manual-implementation"><a href="#option-3-manual-implementation">Option 3: Manual implementation</a></h3>
<p>This should only be done if absolutely necessary, since it requires upholding several
conditions that cannot be properly checked by <code>sscanf</code>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Color {
    r: u8,
    g: u8,
    b: u8,
}

<span class="kw">impl </span>sscanf::RegexRepresentation <span class="kw">for </span>Color {
    <span class="comment">// matches &#39;#&#39; followed by 3 capture groups with 2 hexadecimal digits each
    //
    // Capture groups are normally not allowed in RegexRepresentation, because the default
    // `FromStr` blanket implementation does not handle them. Since this is a manual
    // implementation of `FromScanf`, we can handle them ourselves.
    </span><span class="kw">const </span>REGEX: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str = <span class="string">r&quot;#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})&quot;</span>;
    <span class="comment">//                            # \_____r______/  \_____g______/  \_____b______/
</span>}

<span class="kw">impl </span>sscanf::FromScanf&lt;<span class="lifetime">&#39;_</span>&gt; <span class="kw">for </span>Color {
    <span class="doccomment">/// The Error type in case parsing fails. In this case it is set to never fail (Infallible),
    /// since if the above regex matches, the parsing cannot fail.
    </span><span class="kw">type </span><span class="prelude-val">Err </span>= std::convert::Infallible;
    <span class="kw">const </span>NUM_CAPTURES: usize = <span class="number">4</span>; <span class="comment">// 3 capture groups + the whole match
    </span><span class="kw">fn </span>from_matches(src: <span class="kw-2">&amp;mut </span>regex::SubCaptureMatches) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="kw">let _ </span>= src.next().unwrap().unwrap(); <span class="comment">// skip the whole match
        // note the double-unwrap, since SubCaptureMatches::next() returns an Option&lt;Option&lt;Match&gt;&gt;

        // checking the prefix is not necessary here, since the regex already enforces it

        </span><span class="kw">let </span>r_str = src.next().unwrap().unwrap().as_str(); <span class="comment">// unwrap is ok because the regex only matches if all capture groups match
        </span><span class="kw">let </span>r = u8::from_str_radix(r_str, <span class="number">16</span>).unwrap();
        <span class="kw">let </span>g_str = src.next().unwrap().unwrap().as_str();
        <span class="kw">let </span>g = u8::from_str_radix(g_str, <span class="number">16</span>).unwrap();
        <span class="kw">let </span>b_str = src.next().unwrap().unwrap().as_str();
        <span class="kw">let </span>b = u8::from_str_radix(b_str, <span class="number">16</span>).unwrap();
        <span class="comment">// note that every result can be unwrapped here:
        // This is possible because this trait is only used on a match to the RegexRepresentation::REGEX,
        // which guarantees that everything is in the correct format. This means that the matched
        // text for each capture group is guaranteed to be a valid u8 in hexadecimal format.

        </span><span class="prelude-val">Ok</span>(Color { r, g, b })
    }
}

<span class="kw">let </span>input = <span class="string">&quot;color: #ff12cc&quot;</span>;
<span class="kw">let </span>parsed = <span class="macro">sscanf::sscanf!</span>(input, <span class="string">&quot;color: {Color}&quot;</span>).unwrap();
<span class="macro">assert_eq!</span>(parsed.r, <span class="number">0xff</span>); <span class="macro">assert_eq!</span>(parsed.g, <span class="number">0x12</span>); <span class="macro">assert_eq!</span>(parsed.b, <span class="number">0xcc</span>);</code></pre></div>
<p>This option usually has a faster runtime than <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a>, since it can have capture groups
match during the initial parsing instead of having to parse the string again in the
<a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a> implementation.</p>
<p>The downside is that it requires manually upholding the <a href="trait.FromScanf.html#associatedconstant.NUM_CAPTURES" title="associated constant sscanf::FromScanf::NUM_CAPTURES"><code>NUM_CAPTURES</code></a>
contract, which cannot be checked at compile time. It is also mostly not checked at runtime,
since this would require overhead that is unnecessary in all intended cases. This means that
an error in one implementation might cause a panic in another implementation, which is
near-impossible to debug.</p>
<p>The contract is:</p>
<ul>
<li><code>NUM_CAPTURES</code> <strong>IS EQUAL TO</strong></li>
<li>the number of consumed elements from the iterator passed to <a href="trait.FromScanf.html#tymethod.from_matches" title="associated function sscanf::FromScanf::from_matches"><code>from_matches</code></a> <strong>IS EQUAL TO</strong></li>
<li>1 + the number of unescaped capture groups in <a href="trait.RegexRepresentation.html" title="trait sscanf::RegexRepresentation"><code>RegexRepresentation</code></a> (or <code>{:/.../}</code>).
The 1 is for the whole match, which is a capture group added by <code>sscanf</code>.</li>
</ul>
<p>All of these are automatically enforced by the derive macro or the <a href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr"><code>FromStr</code></a> implementation,
which is why they should be preferred over this option.</p>
<h5 id="lifetime-parameter"><a href="#lifetime-parameter">Lifetime Parameter</a></h5>
<p>The lifetime parameter of <code>FromScanf</code> is the borrow from the input string given to <code>sscanf</code>.
If your type borrows parts of that string, like <code>&amp;str</code> does, you need to specify the lifetime
parameter and match it with the <em>second</em> lifetime parameter of [<code>regex::SubCaptureMatches</code>]:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Name&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>&gt; {
    first: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    last: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>str,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>&gt; sscanf::RegexRepresentation <span class="kw">for </span>Name&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>&gt; {
    <span class="kw">const </span>REGEX: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static </span>str = <span class="string">r&quot;(\w+) (\w+)&quot;</span>;
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;t</span>&gt; sscanf::FromScanf&lt;<span class="lifetime">&#39;t</span>&gt; <span class="kw">for </span>Name&lt;<span class="lifetime">&#39;t</span>, <span class="lifetime">&#39;t</span>&gt; { <span class="comment">// both parts are given the same input =&gt; same lifetime
    </span><span class="kw">type </span><span class="prelude-val">Err </span>= std::convert::Infallible;
    <span class="kw">const </span>NUM_CAPTURES: usize = <span class="number">3</span>;
    <span class="kw">fn </span>from_matches(src: <span class="kw-2">&amp;mut </span>regex::SubCaptureMatches&lt;<span class="lifetime">&#39;_</span>, <span class="lifetime">&#39;t</span>&gt;) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="self">Self</span>, <span class="self">Self</span>::Err&gt; {
        <span class="kw">let _ </span>= src.next().unwrap().unwrap(); <span class="comment">// skip the whole match
        </span><span class="kw">let </span>first = src.next().unwrap().unwrap().as_str();
        <span class="kw">let </span>last = src.next().unwrap().unwrap().as_str();
        <span class="prelude-val">Ok</span>(<span class="self">Self </span>{ first, last })
    }
}

<span class="kw">let </span>input = String::from(<span class="string">&quot;John Doe&quot;</span>);
<span class="kw">let </span>parsed = <span class="macro">sscanf::sscanf!</span>(input, <span class="string">&quot;{Name}&quot;</span>).unwrap();
<span class="macro">assert_eq!</span>(parsed.first, <span class="string">&quot;John&quot;</span>);
<span class="macro">assert_eq!</span>(parsed.last, <span class="string">&quot;Doe&quot;</span>);</code></pre></div>
<p>This allows custom borrows from the input string to avoid unnecessary allocations. The lifetime
of the returned value is that of the input string:</p>

<div class="example-wrap compile_fail"><a href="#" class="tooltip" title="This example deliberately fails to compile">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Name&lt;<span class="lifetime">&#39;a</span>, <span class="lifetime">&#39;b</span>&gt; {
    first: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>str,
    last: <span class="kw-2">&amp;</span><span class="lifetime">&#39;b </span>str,
}
<span class="comment">// ...same impl setup as above...

</span><span class="kw">let </span>parsed;
{
    <span class="kw">let </span>input = String::from(<span class="string">&quot;John Doe&quot;</span>); <span class="comment">// owned string
    </span>parsed = <span class="macro">sscanf::sscanf!</span>(input, <span class="string">&quot;{Name}&quot;</span>).unwrap();
    <span class="comment">// input is dropped here
</span>}
<span class="macro">println!</span>(<span class="string">&quot;{} {}&quot;</span>, parsed.first, parsed.last); <span class="comment">// use after drop</span></code></pre></div>
</div></details><h2 id="required-associated-types" class="small-section-header">Required Associated Types<a href="#required-associated-types" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedtype.Err" class="method"><a class="srclink rightside" href="../src/sscanf/from_scanf.rs.html#205">source</a><h4 class="code-header">type <a href="#associatedtype.Err" class="associatedtype">Err</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/error/trait.Error.html" title="trait core::error::Error">Error</a> + 'static</h4></section></summary><div class="docblock"><p>Error type</p>
</div></details></div><h2 id="required-associated-consts" class="small-section-header">Required Associated Constants<a href="#required-associated-consts" class="anchor">§</a></h2><div class="methods"><details class="toggle" open><summary><section id="associatedconstant.NUM_CAPTURES" class="method"><a class="srclink rightside" href="../src/sscanf/from_scanf.rs.html#210">source</a><h4 class="code-header">const <a href="#associatedconstant.NUM_CAPTURES" class="constant">NUM_CAPTURES</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></h4></section></summary><div class="docblock"><p>Number of captures taken by this regex.</p>
<p><strong>HAS</strong> to match the number of unescaped capture groups in the <a href="trait.RegexRepresentation.html" title="trait sscanf::RegexRepresentation"><code>RegexRepresentation</code></a>
+1 for the whole match.</p>
</div></details></div><h2 id="required-methods" class="small-section-header">Required Methods<a href="#required-methods" class="anchor">§</a></h2><div class="methods"><details class="toggle method-toggle" open><summary><section id="tymethod.from_matches" class="method"><a class="srclink rightside" href="../src/sscanf/from_scanf.rs.html#214">source</a><h4 class="code-header">fn <a href="#tymethod.from_matches" class="fn">from_matches</a>(src: &amp;mut SubCaptureMatches&lt;'_, 't&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, Self::<a class="associatedtype" href="trait.FromScanf.html#associatedtype.Err" title="type sscanf::FromScanf::Err">Err</a>&gt;</h4></section></summary><div class="docblock"><p>The implementation of the parsing.</p>
<p><strong>HAS</strong> to take <strong>EXACTLY</strong> <code>NUM_CAPTURES</code> elements from the iterator.</p>
</div></details></div><h2 id="implementors" class="small-section-header">Implementors<a href="#implementors" class="anchor">§</a></h2><div id="implementors-list"><details class="toggle implementors-toggle"><summary><section id="impl-FromScanf%3C't%3E-for-T" class="impl"><a class="srclink rightside" href="../src/sscanf/from_scanf.rs.html#217-232">source</a><a href="#impl-FromScanf%3C't%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;'t, T&gt; <a class="trait" href="trait.FromScanf.html" title="trait sscanf::FromScanf">FromScanf</a>&lt;'t&gt; for T<span class="where fmt-newline">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a> + 'static,
    &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html" title="trait core::str::traits::FromStr">FromStr</a>&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/str/traits/trait.FromStr.html#associatedtype.Err" title="type core::str::traits::FromStr::Err">Err</a>: <a class="trait" href="https://doc.rust-lang.org/nightly/core/error/trait.Error.html" title="trait core::error::Error">Error</a> + 'static,</span></h3></section></summary><div class="impl-items"><section id="associatedtype.Err-1" class="associatedtype trait-impl"><a href="#associatedtype.Err-1" class="anchor">§</a><h4 class="code-header">type <a href="#associatedtype.Err" class="associatedtype">Err</a> = <a class="struct" href="struct.FromStrFailedError.html" title="struct sscanf::FromStrFailedError">FromStrFailedError</a>&lt;T&gt;</h4></section><section id="associatedconstant.NUM_CAPTURES-1" class="associatedconstant trait-impl"><a class="srclink rightside" href="../src/sscanf/from_scanf.rs.html#223">source</a><a href="#associatedconstant.NUM_CAPTURES-1" class="anchor">§</a><h4 class="code-header">const <a href="#associatedconstant.NUM_CAPTURES" class="constant">NUM_CAPTURES</a>: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a> = 1usize</h4></section></div></details></div><script src="../implementors/sscanf/from_scanf/trait.FromScanf.js" async></script></section></div></main></body></html>